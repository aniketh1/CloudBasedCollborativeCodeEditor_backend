// backend/index.js

const express = require('express');
const http = require('http');
const cors = require('cors');
const { Server } = require('socket.io');
const { spawn } = require('child_process');
// Clerk integration commented out for now - will add later
// const { clerkMiddleware, requireAuth } = require('@clerk/clerk-sdk-node');
require('dotenv').config();

// Database connection
const { connectDB } = require('./config/database');

// Models (commented out temporarily to get basic server running)
// const User = require('./models/User');
// const Session = require('./models/Session');
// const Room = require('./models/Room');
const Project = require('./models/Project');

// Services
const FileSystemService = require('./services/FileSystemService');

// Routes (commented out temporarily)
// const authRoutes = require('./routes/auth');
// const roomRoutes = require('./routes/rooms');
const projectRoutes = require('./routes/projects');
const filesystemRoutes = require('./routes/filesystem');

// Middleware (commented out temporarily)
// const { authenticateSocket, createRateLimit } = require('./middleware/auth');

const app = express();

// Initialize Clerk (commented out for now)
// app.use(clerkMiddleware());

// Middleware
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true
}));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Rate limiting (commented out temporarily)
// app.use('/api/auth/register', createRateLimit(15 * 60 * 1000, 5)); // 5 requests per 15 minutes
// app.use('/api/auth/login', createRateLimit(15 * 60 * 1000, 10)); // 10 requests per 15 minutes

// Routes (commented out temporarily)
// app.use('/api/auth', authRoutes);
// app.use('/api/rooms', roomRoutes);
app.use('/api/projects', projectRoutes);
app.use('/api/filesystem', filesystemRoutes);

// Health check endpoint (simplified)
app.get('/api/health', async (req, res) => {
  try {
    res.json({
      success: true,
      status: 'healthy',
      timestamp: new Date().toISOString(),
      message: 'Server is running'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      status: 'unhealthy',
      error: error.message
    });
  }
});

const server = http.createServer(app);

const io = new Server(server, {
  cors: {
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    methods: ['GET', 'POST'],
    credentials: true
  }
});

// Store active room sessions (simplified structure)
const activeRooms = new Map(); // roomId -> { participants: Set, code: '', files: [], project: null }
const userSockets = new Map(); // userId -> socketId
const terminalSessions = new Map(); // socketId -> { process: childProcess, projectId: string, cwd: string }

// Helper function to get mock file content for demo purposes
function getMockFileContent(filePath) {
  const templates = {
    'src/App.jsx': `import React from 'react';
import './style.css';

function App() {
  return (
    <div className="App">
      <header className="App-header">
        <h1>Welcome to Collab Dev!</h1>
        <p>This is a collaborative code editor.</p>
        <p>Start editing to see real-time collaboration in action.</p>
      </header>
    </div>
  );
}

export default App;`,
    
    'src/index.js': `import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);`,

    'src/style.css': `.App {
  text-align: center;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
}

.App-header {
  background-color: #282c34;
  padding: 40px;
  color: white;
  min-height: 60vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

h1 {
  font-size: 2.5rem;
  margin-bottom: 1rem;
}

p {
  font-size: 1.2rem;
  margin: 0.5rem 0;
}`,

    'public/index.html': `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Collaborative Code Editor" />
    <title>Collab Dev</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>`,

    'package.json': `{
  "name": "collab-dev-project",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}`,

    'README.md': `# Collab Dev Project

This is a collaborative coding project created with Collab Dev.

## Available Scripts

In the project directory, you can run:

### \`npm start\`

Runs the app in development mode.
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

### \`npm test\`

Launches the test runner in interactive watch mode.

### \`npm run build\`

Builds the app for production to the \`build\` folder.

## Features

- Real-time collaborative editing
- Integrated terminal
- File explorer
- Syntax highlighting
- Live preview

Start editing any file to see the magic happen!`,

    'components/Navbar.jsx': `import React from 'react';

function Navbar() {
  return (
    <nav style={{ 
      padding: '1rem', 
      backgroundColor: '#282c34', 
      color: 'white',
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center'
    }}>
      <h2>Collab Dev</h2>
      <div>
        <button style={{ marginRight: '1rem' }}>Save</button>
        <button>Share</button>
      </div>
    </nav>
  );
}

export default Navbar;`,

    'components/Editor.jsx': `import React, { useState } from 'react';

function Editor() {
  const [code, setCode] = useState('// Start coding here...');

  return (
    <div style={{ padding: '1rem' }}>
      <h3>Code Editor</h3>
      <textarea
        value={code}
        onChange={(e) => setCode(e.target.value)}
        style={{
          width: '100%',
          height: '300px',
          fontFamily: 'monospace',
          fontSize: '14px',
          padding: '1rem',
          border: '1px solid #ccc',
          borderRadius: '4px'
        }}
      />
    </div>
  );
}

export default Editor;`
  };

  return templates[filePath] || `// ${filePath}
// This is a demo file in the collaborative editor
// Start editing to see real-time collaboration!

console.log('Hello from ${filePath}');`;
}

// Helper function to detect file language
function getFileLanguage(filePath) {
  const extension = filePath.split('.').pop()?.toLowerCase();
  const languageMap = {
    js: 'javascript',
    jsx: 'javascript',
    ts: 'typescript',
    tsx: 'typescript',
    py: 'python',
    java: 'java',
    cpp: 'cpp',
    c: 'c',
    css: 'css',
    html: 'html',
    json: 'json',
    md: 'markdown',
    txt: 'plaintext',
  };
  return languageMap[extension] || 'plaintext';
}

io.on('connection', async (socket) => {
  console.log(`üîå User connected: ${socket.id}`);
  
  // V2: Enhanced join-room handler with better debugging
  socket.on('join-room', async (roomId) => {
    try {
      console.log(`üìù V2: User ${socket.id} joining room ${roomId}`);
      
      // Join socket to room
      socket.join(roomId);
      
      // Try to find associated project
      let project = null;
      try {
        project = await Project.findByRoomId(roomId);
        console.log(`üîç V2: Project lookup result:`, project ? `Found: ${project.name}` : 'Not found');
      } catch (error) {
        console.log(`‚ö†Ô∏è V2: No project found for room ${roomId}, creating basic room`);
      }
      
      // Initialize room if it doesn't exist
      if (!activeRooms.has(roomId)) {
        let initialFiles = [];
        let initialCode = '// Welcome to CodeDev V2!\n// This is a simpler, cleaner approach\n// Start coding...';
        
        if (project) {
          // Load actual project files recursively
          try {
            console.log(`üìÇ V2: Loading files for project: ${project.name} at ${project.localPath}`);
            initialFiles = await FileSystemService.getDirectoryStructureRecursive(project._id.toString());
            console.log(`üìÅ V2: Successfully loaded ${initialFiles.length} root items with full nested structure`);
            console.log(`üìã V2: File structure:`, JSON.stringify(initialFiles, null, 2));
            initialCode = `// Project: ${project.name}\n// Path: ${project.localPath}\n// Files loaded: ${initialFiles.length} (with nested contents)\n// Ready to code!`;
          } catch (error) {
            console.error('‚ùå V2: Error loading project files:', error);
            // Fallback to default structure
            initialFiles = [
              { 
                name: 'src', 
                type: 'directory', 
                path: 'src',
                children: [
                  { name: 'App.js', type: 'file', path: 'src/App.js' },
                  { name: 'index.js', type: 'file', path: 'src/index.js' },
                ]
              },
              { name: 'package.json', type: 'file', path: 'package.json' },
              { name: 'README.md', type: 'file', path: 'README.md' },
            ];
          }
        } else {
          // Default files for non-project rooms
          console.log(`üìÇ V2: No project found for room ${roomId}, using default file structure`);
          initialFiles = [
            { 
              name: 'src', 
              type: 'directory', 
              path: 'src',
              children: [
                { name: 'App.jsx', type: 'file', path: 'src/App.jsx' },
                { name: 'index.js', type: 'file', path: 'src/index.js' },
                { name: 'style.css', type: 'file', path: 'src/style.css' },
              ]
            },
            { 
              name: 'public', 
              type: 'directory', 
              path: 'public',
              children: [
                { name: 'index.html', type: 'file', path: 'public/index.html' },
                { name: 'favicon.ico', type: 'file', path: 'public/favicon.ico' },
              ]
            },
            { name: 'package.json', type: 'file', path: 'package.json' },
            { name: 'README.md', type: 'file', path: 'README.md' },
          ];
        }
        
        activeRooms.set(roomId, {
          participants: new Set(),
          code: initialCode,
          files: initialFiles,
          project: project
        });
        
        console.log(`üè† V2: Room ${roomId} initialized with ${initialFiles.length} files`);
      }
      
      // Add user to room
      const room = activeRooms.get(roomId);
      room.participants.add(socket.id);
      
      // Send ONLY the project-loaded event (no duplicates)
      console.log(`üì§ V2: Sending project data to ${socket.id}:`);
      console.log(`  - Project: ${room.project ? room.project.name : 'none'}`);
      console.log(`  - Files: ${room.files.length} items`);
      console.log(`  - File names: ${room.files.map(f => f.name).join(', ')}`);
      
      socket.emit('project-loaded', {
        project: room.project,
        files: room.files
      });
      
      // Notify all participants about updated user list
      const participantList = Array.from(room.participants);
      io.to(roomId).emit('update-user-list', participantList);
      
      console.log(`‚úÖ V2: User ${socket.id} joined room ${roomId}. Active participants: ${participantList.length}`);
    } catch (error) {
      console.error('‚ùå V2: Join room error:', error);
      socket.emit('room-error', { error: 'Failed to join room' });
    }
  });

  // Handle terminal session start with project context
  socket.on('start-terminal', async (data = {}) => {
    console.log(`üñ•Ô∏è  Starting terminal for socket: ${socket.id}`);
    
    try {
      const { roomId } = data;
      let workingDirectory = process.cwd();
      let projectId = null;
      let room = null;
      
      console.log(`üè† Room ID: ${roomId}`);
      
      // Wait for room to be initialized if needed
      let attempts = 0;
      while (attempts < 10 && roomId && !activeRooms.has(roomId)) {
        console.log(`‚è≥ Waiting for room ${roomId} to be initialized (attempt ${attempts + 1})`);
        await new Promise(resolve => setTimeout(resolve, 100));
        attempts++;
      }
      
      // If room has a project, use project's local path as working directory
      if (roomId && activeRooms.has(roomId)) {
        room = activeRooms.get(roomId);
        if (room.project) {
          workingDirectory = room.project.localPath;
          projectId = room.project._id.toString();
        }
      }
      
      console.log(`üìÅ Terminal working directory: ${workingDirectory}`);
      console.log(`üìÇ Project path: ${room && room.project ? room.project.localPath : 'No project'}`);
      
      // Start a shell session using child_process - Try PowerShell for better Windows compatibility
      const shell = process.platform === 'win32' ? 'powershell.exe' : 'bash';
      const terminalProcess = spawn(shell, process.platform === 'win32' ? ['-NoProfile', '-NoLogo'] : [], {
        cwd: workingDirectory,
        env: { ...process.env, FORCE_COLOR: '1' },
        stdio: ['pipe', 'pipe', 'pipe']
      });

      // Store terminal session
      terminalSessions.set(socket.id, {
        process: terminalProcess,
        projectId: projectId,
        cwd: workingDirectory
      });

      // Send output to client
      terminalProcess.stdout.on('data', (data) => {
        console.log('üì∫ STDOUT data received:', data.toString());
        socket.emit('terminal-output', data.toString());
      });

      terminalProcess.stderr.on('data', (data) => {
        console.log('üì∫ STDERR data received:', data.toString());
        socket.emit('terminal-output', data.toString());
      });

      terminalProcess.on('close', (code) => {
        console.log('üì∫ Process closed with code:', code);
        socket.emit('terminal-output', `\r\nProcess exited with code ${code}\r\n`);
        terminalSessions.delete(socket.id);
      });

      terminalProcess.on('error', (error) => {
        console.error('üì∫ Terminal process error:', error);
        socket.emit('terminal-output', `Error: ${error.message}\r\n`);
      });

      socket.emit('terminal-ready');
      socket.emit('terminal-output', `Terminal ready! Working directory: ${workingDirectory}\r\n`);
      if (room && room.project) {
        socket.emit('terminal-output', `Project: ${room.project.name}\r\n`);
      }
      socket.emit('terminal-output', `Type your commands below:\r\n\r\n`);
    } catch (error) {
      console.error('Terminal start error:', error);
      socket.emit('terminal-output', 'Error starting terminal\r\n');
    }
  });

      // Receive input from client and write to shell
  socket.on('terminal-input', (input) => {
    console.log('üì§ Terminal input received:', input);
    console.log('üì§ Input type:', typeof input, 'Socket ID:', socket.id);
    const session = terminalSessions.get(socket.id);
    if (session && session.process && session.process.stdin.writable) {
      // Extract the actual data string from the input object
      let data = typeof input === 'object' ? input.data : input;
      
      // Additional PowerShell key handling
      if (data === '\x7F') {
        data = '\b'; // Convert DEL to Backspace for PowerShell
        console.log('üîÑ Backend: Converted DEL to Backspace');
      }
      
      console.log('üìù Writing to terminal:', data, 'Code:', data.charCodeAt(0));
      session.process.stdin.write(data);
      
      // If it's Enter key, also flush
      if (data === '\r' || data === '\n') {
        console.log('üîÑ Flushing stdin after Enter key');
        // Try to flush stdout as well
        setTimeout(() => {
          console.log('‚è∞ Checking for delayed output...');
        }, 100);
      }
    } else {
      console.log('‚ùå No terminal session or stdin not writable for socket:', socket.id);
      console.log('‚ùå Session exists:', !!session);
      if (session) {
        console.log('‚ùå Process exists:', !!session.process);
        console.log('‚ùå Stdin writable:', session.process?.stdin?.writable);
      }
    }
  });

  // Debug: Log all events being received
  socket.onAny((eventName, ...args) => {
    if (eventName !== 'join-room-v2' && eventName !== 'terminal-output') {
      console.log('üîç Received event:', eventName, 'from socket:', socket.id);
    }
  });

  // Handle file operations with project integration
  socket.on('read-file', async (data) => {
    try {
      const { roomId, filePath } = data;
      
      if (!activeRooms.has(roomId)) {
        socket.emit('file-error', { error: 'Room not found' });
        return;
      }

      const room = activeRooms.get(roomId);
      
      if (room.project) {
        // Try to read actual project file
        try {
          const fileData = await FileSystemService.readFile(room.project._id.toString(), filePath);
          socket.emit('file-content', {
            path: filePath,
            content: fileData.content,
            language: FileSystemService.getFileLanguage(filePath)
          });
        } catch (error) {
          console.error('Read file error:', error);
          socket.emit('file-error', { error: error.message });
        }
      } else {
        // For demo/non-project rooms, return mock content
        const mockContent = getMockFileContent(filePath);
        socket.emit('file-content', {
          path: filePath,
          content: mockContent,
          language: getFileLanguage(filePath)
        });
      }
    } catch (error) {
      console.error('Read file error:', error);
      socket.emit('file-error', { error: error.message });
    }
  });

  // Handle folder content requests
  socket.on('read-folder', async (data) => {
    try {
      const { roomId, folderPath } = data;
      console.log('üìÅ V2: Read folder request:', { roomId, folderPath });
      
      if (!activeRooms.has(roomId)) {
        socket.emit('folder-error', { error: 'Room not found' });
        return;
      }

      const room = activeRooms.get(roomId);
      
      if (room.project) {
        try {
          const folderContents = await FileSystemService.readFolder(room.project._id.toString(), folderPath);
          console.log('üìÅ V2: Folder contents loaded:', folderPath, folderContents.length, 'items');
          socket.emit('folder-content', {
            path: folderPath,
            children: folderContents
          });
        } catch (error) {
          console.error('üìÅ V2: Read folder error:', error);
          socket.emit('folder-error', { error: error.message });
        }
      } else {
        // For demo/non-project rooms, return empty
        socket.emit('folder-content', {
          path: folderPath,
          children: []
        });
      }
    } catch (error) {
      console.error('üìÅ V2: Read folder error:', error);
      socket.emit('folder-error', { error: error.message });
    }
  });

  socket.on('write-file', async (data) => {
    try {
      const { roomId, filePath, content } = data;
      
      if (!activeRooms.has(roomId)) {
        socket.emit('file-error', { error: 'Room not found' });
        return;
      }

      const room = activeRooms.get(roomId);
      if (!room.project) {
        socket.emit('file-error', { error: 'No project associated with this room' });
        return;
      }

      await FileSystemService.writeFile(room.project._id.toString(), filePath, content);
      
      // Broadcast file change to all participants
      socket.to(roomId).emit('file-updated', { filePath, content });
      
      socket.emit('file-saved', { filePath });
    } catch (error) {
      console.error('Write file error:', error);
      socket.emit('file-error', { error: error.message });
    }
  });

  socket.on('refresh-files', async (data) => {
    try {
      const { roomId } = data;
      
      if (!activeRooms.has(roomId)) {
        socket.emit('file-error', { error: 'Room not found' });
        return;
      }

      const room = activeRooms.get(roomId);
      if (!room.project) {
        socket.emit('file-error', { error: 'No project associated with this room' });
        return;
      }

      const files = await FileSystemService.getDirectoryStructureRecursive(room.project._id.toString());
      room.files = files;
      
      // Broadcast updated file structure to all participants
      io.to(roomId).emit('file-structure-update', files);
    } catch (error) {
      console.error('Refresh files error:', error);
      socket.emit('file-error', { error: error.message });
    }
  });

  // Handle code changes
  socket.on('code-change', ({ roomId, code }) => {
    if (activeRooms.has(roomId)) {
      // Update room's code
      activeRooms.get(roomId).code = code;
      
      // Broadcast to other users in the room
      socket.to(roomId).emit('code-update', code);
    }
  });

  // Handle file structure changes (for non-project rooms)
  socket.on('file-structure-change', ({ roomId, files }) => {
    if (activeRooms.has(roomId)) {
      const room = activeRooms.get(roomId);
      if (!room.project) { // Only allow manual file structure changes for non-project rooms
        room.files = files;
        socket.to(roomId).emit('file-structure-update', files);
      }
    }
  });

  // Handle resize event (simplified - no actual resize for child_process)
  socket.on('resize', ({ cols, rows }) => {
    console.log(`Terminal resize requested: ${cols}x${rows}`);
  });

  // Handle user disconnection
  socket.on('disconnect', () => {
    console.log(`‚ùå User disconnected: ${socket.id}`);
    
    // Clean up terminal process
    const session = terminalSessions.get(socket.id);
    if (session && session.process) {
      session.process.kill();
      terminalSessions.delete(socket.id);
    }

    // Remove user from all active rooms
    for (const [roomId, room] of activeRooms.entries()) {
      if (room.participants.has(socket.id)) {
        room.participants.delete(socket.id);
        
        // Notify other participants
        const participantList = Array.from(room.participants);
        socket.to(roomId).emit('update-user-list', participantList);
        
        // Clean up empty rooms
        if (room.participants.size === 0) {
          activeRooms.delete(roomId);
          console.log(`üóëÔ∏è  Room ${roomId} cleaned up (no active participants)`);
        }
        
        console.log(`üëã User ${socket.id} left room ${roomId}. Remaining participants: ${participantList.length}`);
      }
    }
  });
});

const PORT = process.env.PORT || 3001;

// Initialize database connection and start server
async function startServer() {
  try {
    // Connect to database
    await connectDB();
    console.log('‚úÖ Database connected successfully');
    
    // Start the server
    server.listen(PORT, () => {
      console.log(`üöÄ Server running on port ${PORT}`);
      console.log(`üìù Frontend URL: ${process.env.FRONTEND_URL || 'http://localhost:3000'}`);
      console.log(`üîå Socket.IO ready for connections`);
    });
  } catch (error) {
    console.error('‚ùå Failed to start server:', error);
    process.exit(1);
  }
}

// Start the server
startServer();
